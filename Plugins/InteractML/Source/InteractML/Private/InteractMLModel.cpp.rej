diff a/Plugins/InteractML/Source/InteractML/Private/InteractMLModel.cpp b/Plugins/InteractML/Source/InteractML/Private/InteractMLModel.cpp	(rejected hunks)
@@ -97,51 +97,50 @@
 bool UInteractMLModel::RunModel(FInteractMLParameterSeries* parameter_series, TArray<float>& out_values)
 {
 	return RunModelInstance( parameter_series, out_values );
 }
 
 // train the model with the provided training set
 // NOTE: runs synchronously, i.e. blocks until complete
 //
 void UInteractMLModel::TrainModel(UInteractMLTrainingSet* training_set)
 {
 	//always reset before training
 	ResetModel();
 
 	//propagate label cache (needed for training)
 	LabelCache.Assign( training_set->GetLabelCache() );
 
 	//train
 	bIsTrained = TrainModelInstance(training_set);
 }
 
 // reset the model to initialised but empty
 //
 void UInteractMLModel::ResetModel()
 {
 	ResetModelInstance();
-	LabelCache.Reset();
 	bIsTrained = false;
 }
 
 
 // fallback operation of running a single sample model, can be specialised
 //
 bool UInteractMLModel::RunModelInstance(struct FInteractMLParameterCollection* parameters, TArray<float>& out_values)
 {
 	check(!IsSeries()); //shouldn't be trying to run a series model with single input
 	if (!IsTrained())
 	{
 		UE_LOG(LogInteractML, Warning, TEXT("Running an untrained model: %s"), *GetFilePath());
 		return false;
 	}
 
 	//convert parameter data to RapidLib form
 	std::vector<float> model_inputs;
 	for (int iparam = 0; iparam < parameters->Values.Num(); iparam++)
 	{
 		float value = parameters->Values[iparam];
 		model_inputs.push_back(value);
 	}
 	
 	//run the model
 	modelSetFloat* model = GetModelInstance();
